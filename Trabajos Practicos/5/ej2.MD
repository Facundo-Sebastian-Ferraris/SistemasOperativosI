# Ejercicio 2: AnÃ¡lisis de rendimiento y cachÃ© ğŸ§ 

## Â¿QuÃ© es la cachÃ© TLB de un procesador, quÃ© contiene y para quÃ© se utiliza? ğŸ“

La **cachÃ© TLB (Translation Lookaside Buffer)** es una memoria cachÃ© especializada en el procesador que almacena traducciones recientes de direcciones virtuales a direcciones fÃ­sicas para acelerar el proceso de traducciÃ³n en sistemas con memoria virtual. ğŸš€

- **Contenido**:
  - Mapeos de direcciones virtuales a direcciones fÃ­sicas. ğŸ“
  - Cada entrada incluye:
    - Una direcciÃ³n virtual (o parte de ella, como el nÃºmero de pÃ¡gina virtual). ğŸ”¢
    - La direcciÃ³n fÃ­sica correspondiente. ğŸ 
    - Metadatos como permisos (lectura/escritura), bits de validez y, en algunos casos, informaciÃ³n sobre el tamaÃ±o de la pÃ¡gina (4 KB o 2 MB). ğŸ“
- **Uso**:
  - Cuando un programa accede a una direcciÃ³n de memoria virtual, el procesador consulta la TLB para obtener la direcciÃ³n fÃ­sica. ğŸ”
  - Un "hit" en la TLB evita accesos a las tablas de pÃ¡ginas en memoria, que son mÃ¡s lentos. âœ…
  - Un "miss" requiere una caminata por las tablas de pÃ¡ginas, generando un **TLB miss** que impacta el rendimiento. âŒ
- **RelaciÃ³n con `perf`**:
  - `l1_dtlb_misses`: Fallos en la TLB de nivel 1 para datos. ğŸ“‰
  - `ls_l1_d_tlb_miss.tlb_reload_4k_l2_miss` y `ls_l1_d_tlb_miss.tlb_reload_2m_l2_miss`: Recargas de TLB para pÃ¡ginas de 4 KB o 2 MB desde niveles superiores (L2 o memoria). ğŸ”„

## Â¿QuÃ© es la cachÃ© de datos de un procesador? ğŸ’¾

La **cachÃ© de datos** es una memoria rÃ¡pida en el procesador que almacena copias de datos frecuentemente utilizados de la RAM para reducir la latencia de acceso. âš¡

- **Contenido**:
  - Bloques de datos (lÃ­neas de cachÃ©, tÃ­picamente 64 bytes) copiados desde la RAM. ğŸ“¦
  - Cada lÃ­nea incluye:
    - Los datos en sÃ­. ğŸ“Š
    - Una etiqueta que identifica la direcciÃ³n de memoria. ğŸ·ï¸
    - Metadatos como bits de validez, estado de coherencia y bits de suciedad. ğŸ”§
- **Uso**:
  - Permite accesos rÃ¡pidos a datos sin consultar la RAM. ğŸš€
  - Los `cache-misses` en `perf` indican que los datos no estaban en la cachÃ©, requiriendo accesos a niveles superiores (L2, L3) o RAM. ğŸ“‰

## AnÃ¡lisis de los datos de `perf` y cÃ³digos ğŸ“Š

Los datos de `perf` corresponden a tres programas (`sample1`, `sample2`, `sample3`) que reservan un bloque de memoria de `N * BSIZE` bytes (`240,000 * 4,096 = 983,040,000` bytes â‰ˆ 937 MB) y lo recorren para escribir y verificar valores. Analizamos las preguntas con base en los datos y los cÃ³digos proporcionados. ğŸ–¥ï¸

### Datos de `perf` ğŸ“ˆ

- **sample1**:
  - Tiempo: 26.64 s â±ï¸
  - `l1_dtlb_misses`: 601,573,063 ğŸ“‰
  - `ls_l1_d_tlb_miss.tlb_reload_4k_l2_miss`: 471,953,763 ğŸ”„
  - `ls_l1_d_tlb_miss.tlb_reload_2m_l2_miss`: 309,005 ğŸ”„
  - `cache-misses`: 1,118,111,307 ğŸ“‰
- **sample2**:
  - Tiempo: 7.61 s â±ï¸
  - `l1_dtlb_misses`: 1,222,778 ğŸ“‰
  - `ls_l1_d_tlb_miss.tlb_reload_4k_l2_miss`: 689,068 ğŸ”„
  - `ls_l1_d_tlb_miss.tlb_reload_2m_l2_miss`: 11,140 ğŸ”„
  - `cache-misses`: 5,708,226 ğŸ“‰
- **sample3**:
  - Tiempo: 11.87 s â±ï¸
  - `l1_dtlb_misses`: 246,136,024 ğŸ“‰
  - `ls_l1_d_tlb_miss.tlb_reload_4k_l2_miss`: 245,226,959 ğŸ”„
  - `ls_l1_d_tlb_miss.tlb_reload_2m_l2_miss`: 149,730 ğŸ”„
  - `cache-misses`: 265,851,205 ğŸ“‰

### Â¿QuÃ© versiÃ³n tiene el peor rendimiento? Â¿Encuentra una relaciÃ³n entre ese rendimiento con los fallos de cachÃ© y TLB reportados por perf? ğŸ“‰

- **Peor rendimiento**: `sample1` (26.64 s) ğŸ˜”
- **AnÃ¡lisis del cÃ³digo**:
  - **Recorrido de escritura**:

    ```c
    for (j=0; j<BSIZE; j++) {
        for (i=0; i<N; i++) {
            *(pp+i*BSIZE+j) = 2; // pp[i][j] = 2;
        }
    }
    ```

  - La memoria se recorre por columnas (`j` en el bucle externo, `i` en el interno), generando accesos no consecutivos con saltos de 4,096 bytes (`i*BSIZE`). ğŸ“
  - **Impacto**:
    - **Baja localidad espacial**: Los accesos separados por 4 KB causan altos `cache-misses` (1,118M), ya que las lÃ­neas de cachÃ© (64 bytes) no se reutilizan. ğŸ§ 
    - **Baja localidad temporal**: Cada acceso puede requerir una nueva pÃ¡gina (4 KB), saturando la TLB (`l1_dtlb_misses`: 601M). ğŸ“
- **RelaciÃ³n**:
  - Los altos fallos TLB y de cachÃ© explican el tiempo elevado. Los accesos no consecutivos generan recargas frecuentes, aumentando la latencia. â³

### Â¿QuÃ© versiÃ³n tiene el mejor rendimiento? Analice en grupo de quÃ© manera el programa de mejor rendimiento recorre la memoria reservada ğŸ†

- **Mejor rendimiento**: `sample2` (7.61 s) ğŸ‰
- **AnÃ¡lisis del cÃ³digo**:
  - **Recorrido de escritura**:

    ```c
    for (i=0; i<N; i++) {
        for (j=0; j<BSIZE; j++) {
            *(pp+i*BSIZE+j) = 2; // pp[i][j] = 2;
        }
    }
    ```

  - La memoria se recorre por filas (`i` en el bucle externo, `j` en el interno), con accesos **secuenciales** dentro de cada bloque de 4,096 bytes. ğŸš¶
  - **Impacto**:
    - **Alta localidad espacial**: Accesos consecutivos (`j` incrementa en 1) llenan lÃ­neas de cachÃ© (64 bytes), reduciendo `cache-misses` (5.7M). ğŸ§ 
    - **Alta localidad temporal**: Cada bloque de 4 KB se procesa completamente, minimizando recargas de TLB (`l1_dtlb_misses`: 1.2M). ğŸ“
    - El bajo `ls_l1_d_tlb_miss.tlb_reload_2m_l2_miss` (11K) sugiere posible uso de pÃ¡ginas grandes (2 MB). ğŸ“
- **ConclusiÃ³n**: `sample2` recorre la memoria secuencialmente, maximizando la reutilizaciÃ³n de cachÃ© y TLB, lo que explica su mejor rendimiento. âœ…

### Â¿QuÃ© diferencia existe en la manera de recorrer la memoria entre el programa de mejor rendimiento y el de rendimiento medio? Hipotetice o explique por quÃ© razÃ³n el programa de mejor rendimiento supera al de rendimiento medio ğŸŒŸ

- **Rendimiento medio**: `sample3` (11.87 s) âš–ï¸
- **AnÃ¡lisis del cÃ³digo**:
  - **Recorrido de escritura**:

    ```c
    for (k=0; k<BSIZE/SMALL; k++) {
        for (i=0; i<N; i++) {
            for (j=0; j<SMALL; j++) {
                *(pp+i*BSIZE+(SMALL*k+j)) = 2; // pp[i][SMALL*k+j] = 2;
            }
        }
    }
    ```

  - La memoria se recorre en bloques de 4 bytes (`SMALL`). Para cada `k`, se accede a todos los `i` (saltos de 4 KB) y `j` (0 a 3). ğŸ“
  - **Impacto**:
    - **Localidad espacial moderada**: Accesos consecutivos dentro de 4 bytes, pero saltos de 4 KB entre filas causan mÃ¡s `cache-misses` (265M). ğŸ§ 
    - **Localidad temporal baja**: Accesos a la misma pÃ¡gina se distribuyen en mÃºltiples iteraciones de `k`, aumentando `l1_dtlb_misses` (246M). ğŸ“
    - Uso predominante de pÃ¡ginas de 4 KB (`ls_l1_d_tlb_miss.tlb_reload_4k_l2_miss`: 245M). ğŸ“

- **Diferencias con `sample2`**:
  - **sample2**: Recorre cada bloque de 4 KB secuencialmente, maximizando localidad. ğŸš¶
  - **sample3**: Divide el recorrido en bloques de 4 bytes con saltos de 4 KB, rompiendo la localidad. ğŸƒ
- **Razones del mejor rendimiento de `sample2`**:
  - **Localidad espacial**: Accede a direcciones consecutivas, llenando lÃ­neas de cachÃ© eficientemente. ğŸ§ 
  - **Localidad temporal**: Procesa un bloque completo, reutilizando entradas TLB. ğŸ“
  - **PÃ¡ginas grandes**: Menos recargas de TLB (`ls_l1_d_tlb_miss.tlb_reload_2m_l2_miss`: 11K). ğŸ“
  - **sample3** alterna entre bloques de 4 KB, causando mÃ¡s fallos. ğŸ˜•
- **RelaciÃ³n con `perf`**:
  - Los fallos de `sample3` (246M TLB, 265M cachÃ©) son ~200 veces mayores que los de `sample2` (1.2M TLB, 5.7M cachÃ©), explicando la diferencia de ~4 segundos. â³

### Diagrama de la memoria y la forma en que se recorre ğŸ—ºï¸

La memoria reservada (`pp`) es un arreglo de `N * BSIZE` bytes (937 MB), interpretado como una matriz de `N` filas (240,000) y `BSIZE` columnas (4,096 bytes). ğŸ“

**Diagrama conceptual (texto)**:

```bash
Memoria reservada (pp):
[ Fila 0: [0, 1, ..., 4095] ][ Fila 1: [4096, 4097, ..., 8191] ] ... [ Fila N-1 ] ğŸ“¦

CachÃ© L1 (lÃ­neas de 64 bytes):
[ LÃ­nea 1 | LÃ­nea 2 | ... ] ğŸ§ 

TLB (entradas para pÃ¡ginas de 4 KB o 2 MB):
[ PÃ¡gina virtual 1 -> FÃ­sica 1 ]
[ PÃ¡gina virtual 2 -> FÃ­sica 2 ] ğŸ“

Recorrido de memoria:
- sample2 (mejor rendimiento) ğŸ†:
  Secuencial por filas:
  [Fila 0: 0, 1, 2, ..., 4095] -> [Fila 1: 4096, 4097, ..., 8191] -> ... ğŸš¶
  - Accesos consecutivos dentro de cada fila (4 KB).
  - MÃ¡xima localidad espacial: llena lÃ­neas de cachÃ© (64 bytes). ğŸ§ 
  - MÃ­nimos fallos TLB: una pÃ¡gina (4 KB) cubre una fila. ğŸ“
  Ejemplo: for (i=0; i<N; i++) for (j=0; j<BSIZE; j++) pp[i*BSIZE+j] = 2;

- sample3 (rendimiento medio) âš–ï¸:
  Por bloques de 4 bytes con saltos de 4 KB:
  [Fila 0: 0,1,2,3] -> [Fila 1: 4096,4097,4098,4099] -> ... -> [Fila N-1] -> [Fila 0: 4,5,6,7] -> ... ğŸƒ
  - Localidad espacial limitada: accesos consecutivos solo dentro de 4 bytes.
  - Saltos de 4 KB generan mÃ¡s fallos de cachÃ© y TLB. ğŸ“‰
  Ejemplo: for (k=0; k<BSIZE/4; k++) for (i=0; i<N; i++) for (j=0; j<4; j++) pp[i*BSIZE+(4*k+j)] = 2;

- sample1 (peor rendimiento) ğŸ˜”:
  Por columnas:
  [Fila 0: 0] -> [Fila 1: 4096] -> ... -> [Fila N-1] -> [Fila 0: 1] -> ... ğŸ¢
  - Accesos no consecutivos (saltos de 4 KB).
  - MÃ­nima localidad: altos fallos de cachÃ© y TLB. ğŸ“‰
  Ejemplo: for (j=0; j<BSIZE; j++) for (i=0; i<N; i++) pp[i*BSIZE+j] = 2;
```

**GrÃ¡fico comparativo** (cÃ³digo Chart.js para visualizar fallos) ğŸ“Š:

```javascript
{
  "type": "bar",
  "data": {
    "labels": ["sample1 ğŸ˜”", "sample2 ğŸ†", "sample3 âš–ï¸"],
    "datasets": [
      {
        "label": "L1 DTLB Misses (millones) ğŸ“‰",
        "data": [601.573, 1.223, 246.136],
        "backgroundColor": "rgba(255, 99, 132, 0.8)"
      },
      {
        "label": "Cache Misses (millones) ğŸ“‰",
        "data": [1118.111, 5.708, 265.851],
        "backgroundColor": "rgba(54, 162, 235, 0.8)"
      }
    ]
  },
  "options": {
    "scales": {
      "y": {
        "beginAtZero": true,
        "title": {
          "display": true,
          "text": "Cantidad (millones)"
        }
      },
      "x": {
        "title": {
          "display": true,
          "text": "Programa"
        }
      }
    },
    "plugins": {
      "legend": {
        "display": true
      }
    }
  }
}
```

## Resumen ğŸ“

- **Peor rendimiento**: `sample1` (26.64 s ğŸ˜”) recorre por columnas, con saltos de 4 KB, causando altos `cache-misses` (1,118M) y `l1_dtlb_misses` (601M). ğŸ“‰
- **Mejor rendimiento**: `sample2` (7.61 s ğŸ†) recorre por filas, con accesos secuenciales, minimizando `cache-misses` (5.7M) y `l1_dtlb_misses` (1.2M). ğŸš¶
- **Rendimiento medio**: `sample3` (11.87 s âš–ï¸) usa bloques de 4 bytes con saltos de 4 KB, generando mÃ¡s fallos (`cache-misses`: 265M, `l1_dtlb_misses`: 246M). ğŸƒ
- **Razones de la diferencia**: `sample2` supera a `sample3` por su recorrido secuencial, que maximiza localidad y aprovecha pÃ¡ginas grandes (2 MB). ğŸŒŸ
